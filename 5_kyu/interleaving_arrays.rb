# Create a function, that accepts an arbitrary number of arrays and returns a
# single array generated by alternately appending elements from the passed in
# arguments. If one of them is shorter than the others, the result should be
# padded with nils.

# Input: An arbitrary number of arrays
# Output: A single array of interspersed elements from the argument arrays

# Data Structures:
# Arrays

# Considerations:
#   Empty array returns empty array
#   Uneven element arrays get padded with nil
#   Single array returns itself,I guess.

# Algorithm:
#   Take multiple arguments with *
#   Create a return array
#   find the length of the largest array
#     the length of max_by length
#   iterate length times with index
#   for each index value, iterate over the argument arrays and append that value to the return array.

def interleave(*arrays)
  return [] if arrays.empty?
  inter_array = []

  arrays.max_by(&:length).size.times do |index|
    arrays.each { |array| inter_array << array[index] }
  end

  inter_array
end

def interleave(*arrays)
  return [] if arrays.empty?
  start_arr = arrays[0] + [nil] * (arrays.max_by(&:size).size - arrays[0].size)
  start_arr.zip(*arrays[1..]).flatten
end

p interleave([1,2, 3])

# Examples:

p interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
p interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, nil]
p interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
p interleave([]) == []
p interleave([], [])